---

# 第1章 クリーンアーキテクチャ

クリーンアーキテクチャは、主に **4つの層** に分けられます。

1. **ドメインモデル（Entity層）**
    人が何と言おうと「事実」である部分を示す。
    → アプリケーションの中心となるビジネスルールや概念を表す層。
    （例：ユーザー、注文、商品などのドメインオブジェクト）

2. **ユースケース（Use Case層）**
    「人が何をしたいか」を示す部分。
    → ドメインモデルを使って実現したい操作やビジネスフローを定義する層。
    （例：注文を作成する、支払いを処理する、レポートを生成する など）

3. **インターフェースアダプター（Interface Adapter層）**
    アプリケーションの「枠組み作り」に関する部分。
    → 内部のユースケースと外部の入出力（Web API、DB、UIなど）を橋渡しする層。
    （例：コントローラ、プレゼンター、リポジトリの実装など）

4. **インフラストラクチャー（Infrastructure層）**
    下支えとしての動作の実態を示す。
    → 外部の技術的要素（DB接続、API通信、フレームワーク依存部分など）を扱う層。
    ここはアプリケーションの土台となるが、ビジネスルールとは切り離される。


---

### 💡補足

- 各層は**内側ほど抽象的で普遍的**、外側ほど**具体的で変化しやすい**構造を持ちます。

- 依存関係は**内側に向かう**ように設計される（＝外側の層が内側の層に依存し、逆はない）。

- 目的は「変更に強く、再利用しやすい」構成を実現することです。


---

# 第2章 パッケージ原則

## パッケージ設計の基本的な考え方

利用しやすいパッケージ設計とは、**小さい機能ごとに分けられている設計**である。アプリケーションは責務・責任で分けるべきである。

> **重要な考え方**
> 分かれすぎていて難しいというよりも、一つの箱の中にいろんなものが入りすぎて切り出すのが難しい方が後から辛くなってしまう。

## パッケージ原則の6つの概念

1. **再利用リリース等価の原則**（REP: Reuse Release Equivalency Principle）
2. **全再利用の原則**（CRP: Common Reuse Principle）
3. **閉鎖性共通の原則**（CCP: Common Closure Principle）
4. **非循環依存関係の原則**（ADP: Acyclic Dependencies Principle）
5. **安定依存の原則**（SDP: Stable Dependencies Principle）
6. **安定度・抽象度等価の原則**（SAP: Stable Abstractions Principle）

### 1. 再利用リリース等価の原則（REP）
できるだけプログラムの共通する部分を再利用できるようにしましょうという方針のこと。

### 2. 全再利用の原則（CRP）
パッケージ利用者に「ここは必要だけど、ここは採用したくない」といった取捨選択の権限がないこと。すべて利用するしかないという制約。

### 3. 閉鎖性共通の原則（CCP）
一つの変更が必要なときに、できる限り**一つのパッケージだけを交換すれば済む形**にしなさいという原則。

### 4. 非循環依存関係の原則（ADP）
パッケージの依存が循環してはならないというシンプルな原則。依存関係の循環は避けるべき。

### 5. 安定依存の原則（SDP）
パッケージの依存は常に**安定したパッケージに向く**という真理を語っている原則。

### 6. 安定度・抽象度等価の原則（SAP）
パッケージの**安定度と抽象度には相関関係がある**ということを説明している原則。

---

# 第3章 オブジェクト指向

## オブジェクト指向の前提

まず前提として**オブジェクト指向には明確な定義がない**。

どんどん肥大化してしまうプログラミングの難しさを、単に物のイメージで優しくできないかという試みを、業界はオブジェクト指向と呼んでいただけである。

## オブジェクト指向の3つの基本概念

### 1. カプセル化（Encapsulation）
相互に関連性の高い知識群を**一つのオブジェクトの中に閉じ込める**のがカプセル化です。

### 2. 多様性（Polymorphism）
一言で言えば、**プラグインのこと**。
本体側から見るとどれも同じに見えるが、実は中身の違う数多くの実体があるということ。

### 3. 継承/汎化（Inheritance/Generalization）
**共通の性質や機能を持つオブジェクト同士の関係性**を表現する仕組み。

- **継承**：親クラスの性質や機能を子クラスが受け継ぐこと
  - 例：「動物」クラスから「犬」「猫」クラスが継承
- **汎化**：複数のクラスから共通部分を抽出して、より一般的な概念（親クラス）を作ること
  - 例：「犬」「猫」の共通点から「動物」という概念を抽出

> **注意点**
> 継承は「is-a関係」（〜は〜である）が成り立つ場合にのみ使用すべき。
> 単なるコード再利用が目的なら、継承よりも委譲やコンポジションを検討する。

## 💡補足：コードの再利用について

コードを再利用したいだけであれば、継承などは使用せずに、他の関数やオブジェクトのメソッドに移動すれば良いです。

# 第4章 UML
UML（統一モデリング言語）は、設計者同士のコミュニケーションで図を使って振る舞い・構造を可視化するための手法です。主な図の例：

- インスタンス図：実行時のオブジェクトの状態や関係を表す。
- シーケンス図：ある処理におけるオブジェクト間のメッセージや時間順のやり取りを表す。

図を用いることで、設計意図や処理の流れをチームで共有しやすくなります。

# 第5章 オブジェクト思考原則 SOLID
SOLID は設計を安定化させるための5つの原則（頭文字）です。短く要点を示します。

- S: Single Responsibility Principle（単一責任原則） — クラスやモジュールは「ひとつの責務」だけを持つべき。変更理由が1つになるように分割する。
- O: Open-Closed Principle（開放／閉鎖の原則） — ソフトウェア要素は拡張に対して開かれ、修正に対して閉じているべき（抽象化で既存コードを直接変更しない）。
- L: Liskov Substitution Principle（リスコフの置換原則） — サブタイプはスーパタイプの代わりに使っても正しく動作するべき。継承は振る舞いの契約を壊さないことが重要。
- I: Interface Segregation Principle（インターフェース分離の原則） — クライアントは使わないメソッドを強制されるべきではない。小さく特化したインターフェースを作る。
- D: Dependency Inversion Principle（依存性逆転の原則） — 高水準モジュールも低水準モジュールも抽象に依存する。具象実装ではなく抽象（インターフェース）に依存させる。

設計上の実用ヒント：継承を安易に使わずまずは委譲・コンポジションを検討すること、UML（特にシーケンス図）で振る舞いを確認してからSOLIDに沿ってクラスやインターフェースを割り当てると設計が安定します。

# 第6章 テスト駆動開発（TDD）
単体テストは「1つのモジュール（またはクラス）」に焦点を当てる最小単位のテストです。上位モジュールで下位の責務まで再検証するとシナリオが爆発するため、単体テストでは対象ロジックの検証に集中します。

## テストダブル（外部依存の置き換え）
- スタブ（Stub）：決め打ちの戻り値を返し、外部依存を置き換える。検証は目的ではない。
- モック（Mock）：呼び出し回数・引数・順序などの「やり取り」を検証するために使う。

## TDD の基本サイクル（Red-Green-Refactor）
1. テストを追加（まず失敗するテストを書く → Red を確認）
2. 最小限の実装でテストを通す（Green）
3. リファクタリング（振る舞いは保ったま設計を改善）

注意：テストのために本番仕様を歪めない。テストは仕様を先導し、実装は最小で応える。

## BDD（Behaviour Driven Development）
ユーザー機能レベルの振る舞いに焦点を当て、仕様（Given-When-Then）に沿ってテストする手法。目的は「仕様どおりに動く実装」を得ること。

# 第7章 依存性注入（DI: Dependency Injection）
依存性注入は、オブジェクトが必要とする依存（機能の実体）を「自分で生成・解決せず、外部から与えてもらう」設計方針です。目的は、結合度を下げて変更に強くし、テストを容易にすること。

## 役割の分離
- 実装（Use）：与えられた依存をそのまま利用する。最小限のインターフェースに依存する。
- 生成（Create）：適切な具象実装を組み立てて依存として用意する。
- 注入（Inject）：生成した依存を使用者に渡す経路（例：コンストラクタ注入・セッター注入）。

この分離により、利用側は詳細を知らずに抽象へ依存でき、モック・スタブへの差し替えも容易になる。

# 第8章 デザインパターン
デザインパターンは「よくある設計課題への再利用可能な解法のカタログ」。チームの共通言語となり、依存性逆転（DIP）やクリーンアーキテクチャと相性が良い。

## ねらい（何のために使うか）
- 変更に強い構造を素早く組み立てる（差し替え・拡張の容易化）
- 設計議論を短く正確にする（名前＝意図の共有）
- 実装の重複・スパゲッティ化を防ぐ（責務分離）

## 分類（GoFの3群）
- 生成に関するパターン：オブジェクト生成のばらつきを隠す（Abstract Factory / Factory Method / Builder / Prototype / Singleton）
- 構造に関するパターン：クラス・オブジェクトの組み合わせ方（Adapter / Facade / Composite / Decorator / Proxy / Bridge / Flyweight）
- 振る舞いに関するパターン：オブジェクト間のやり取り・アルゴリズムの変化（Strategy / Template Method / Observer / Command / State / Iterator / Mediator / Memento / Visitor / Chain of Responsibility）

## 主要パターンの使いどころ（1行要約）
- Abstract Factory：関連する生成物の「家族」をまとめて切り替える（インフラ差し替えに最適）
- Factory Method：生成をサブクラスに委ねる（型は固定、生成手順だけ揃える）
- Builder：複雑な生成手順を段階的に組み立てる（必須/任意の混在、順序制御）
- Adapter：既存APIを期待インターフェースに合わせる（他ライブラリを包む）
- Facade：複雑なサブシステムに単純な窓口を用意（ユースケースから複雑さを隠す）
- Composite：木構造を個別/集合で同一視（メニュー、ディレクトリなど）
- Decorator：機能を層のように後付け（ログ/キャッシュ/リトライの追加）
- Proxy：アクセスの間に代理を挟む（遅延、リモート、キャッシュ、認可）
- Strategy：アルゴリズムを入れ替え可能に（条件分岐の爆発防止）
- Template Method：不変の枠組み＋差し替えポイント（フックメソッド）
- Observer：イベントの発行/購読（UI、ドメインイベント）
- Command：操作をオブジェクト化（キュー、リトライ、Undo）
- State：状態ごとに振る舞いを切り替え（条件分岐からの解放）

## クリーンアーキテクチャとの接続
- ポート/アダプタ：Adapter/Facade/Proxy/Decorator で外部要素を隔離
- DIP＋DI：Abstract Factory/Factory Method/Builder で具象を組み立て、内側は抽象に依存
- 振る舞い：ユースケース内の分岐を Strategy/State/Template Method で整理


## 選択ガイド（どれを選ぶ？）
- 生成の家族を丸ごと切り替えたい → Abstract Factory（＋DI）
- 実装の差はあるが使い方は同じにしたい → Strategy／Template Method
- 外部ライブラリのIFが合わない → Adapter、複雑さを隠したい → Facade
- 木構造で再帰的な処理を統一 → Composite、機能を後付け → Decorator
- リモート/遅延/キャッシュ/認可を挟みたい → Proxy
- イベント配信/購読 → Observer、操作の蓄積/Undo → Command(+Memento)

## 注意点（アンチパターン回避）
- パターン先行で設計しない（YAGNI）— 必要が明確になってから導入
- 過剰抽象化を避ける — 意図が伝わる最小の構造に留める
- 名前を正しく使う — 意図がズレるとメンテ不能になる

# 第9章 アジャイル開発

アジャイルは「短いサイクルで価値を届け、学びを次の反復に反映する」ための開発姿勢。設計は走りながら育てる（第6章TDD、第7章DI、第8章パターンを活用）。

## アジャイルソフトウェア開発宣言（価値）
- プロセスやツール よりも 個人と対話
- 包括的なドキュメント よりも 動くソフトウェア
- 契約交渉 よりも 顧客との協調
- 計画に従うこと よりも 変化への対応
（左にも価値はあるが、右をより高く評価する）

## DDD（ドメイン駆動設計）の要点
- イビキタス言語：チームで共有する言葉でモデルとコードを一致させる
- モデル駆動：ドメインモデルを中心に設計・実装・テスト・分析・要件を反復で磨く
- 変更に強い設計：抽象（DIP）と境界（ポート/アダプタ）で中心を安定させる

### 用語整理（ビルディングブロック）
- エンティティ（Entity）：同一性（ID）で識別され、状態が変化する概念
- 値オブジェクト（Value Object）：属性値の集合。同一性ではなく値で等価。不変にする
- ドメインサービス（Service）：エンティティやVOに置きづらい振る舞いを表す
- ファクトリ（Factory）：複雑な生成手続きを隠蔽し、正しい完成状態で提供
- リポジトリ（Repository）：集合としての永続化境界。エンティティの取得/保存を抽象化

## 実践サイクル（小さく回す）
1. 目的と用語を合わせる（イビキタス言語）
2. 重要なユースケースを1つ選び、モデルの仮説を立てる
3. TDDで仕様化しつつ最小実装（スタブ/モックで外部依存を隔離）
4. フィードバックでモデル・用語・設計を見直す（リファクタリング）
5. 反復して範囲を拡大（インフラはポート/アダプタで後追い差し替え）

---
